1. 项目流程
Perception (感知) → RetrieveMemory (检索记忆) → Communication (通信) 
    ↑                                                      ↓
    |                                                 Decision (决策)
    |                                                      ↓
UpdateMemory (更新记忆) ← Execution (执行) ←─────────────┘
    |
    └─→ continue (继续循环) / end (结束)

2. 消息队列的数据结构
global_env = {
    "objects": {...},
    "agent_positions": {...},
    "message_queue": [],  # ← 这就是消息队列
    "explored_by_all": set()
}
每条消息都是一个字典
{
    "sender": "Agent1",        # 发送者ID
    "recipient": "Agent2",     # 接收者ID（可以是具体Agent或"all"）
    "message": "我在位置5发现了keyboard"  # 消息内容
}

3. 通信工作流程
在Decision Node中，llm决策时可以选择性地生成一条信息
    messages_text = "\n".join([
        f"- {msg['sender']}: {msg['message']}"
        for msg in context["other_agent_messages"]
    ]) if context["other_agent_messages"] else "No messages from other agents"
LLM返回格式：
    thinking: "我看到了新物体，应该告诉其他Agent"
    action: forward
    reason: "继续探索新区域"
    message_to_others: "我在位置3发现了chair和table"  # ← 可选字段
发送消息，在execution node中检查是否有消息要发送：
    if shared.get("message_to_others"):
        agent_id = shared["agent_id"]
        message = shared["message_to_others"]
        env = shared["global_env"]
        
        with env_lock:
            # Send to all other agents
            add_message(env, agent_id, "all", message)
        
        print(f"[{agent_id}] Sent message: {message}")
    
读取信息，在communication node读取信息：
a. 遍历消息队列
b. 如果消息的接收者是自己或"all"，则提取出来
c. 从队列中删除已读消息（避免重复读取）
d. 返回提取的消息列表
    class CommunicationNode(Node):
    """Communication node: Read messages from other agents"""
    
    def prep(self, shared):
        return shared["agent_id"], shared["global_env"]
    
    def exec(self, prep_res):
        agent_id, env = prep_res
        
        # Thread-safe message reading
        with env_lock:
            messages = get_messages_for(env, agent_id)
        
        return messages
    
    def post(self, shared, prep_res, exec_res):
        shared["other_agent_messages"] = exec_res
        
        if exec_res:
            print(f"[{shared['agent_id']}] Received {len(exec_res)} messages:")
            for msg in exec_res:
                print(f"  From {msg['sender']}: {msg['message']}")
        
        return "default"


4. 记忆系统架构
每个agent有独立的记忆系统
┌────────────────────────────────────────────┐
│         全局环境（共享）                      │
│  - objects（位置和物体）                     │
│  - agent_positions（位置）                  │
│  - message_queue（消息队列）                │
└────────────────────────────────────────────┘
                    │
        ┌───────────┴───────────┐
        ▼                       ▼
┌─────────────────┐    ┌─────────────────┐
│   Agent1记忆    │    │   Agent2记忆    │
│  (独立，私有)    │    │  (独立，私有)    │
├─────────────────┤    ├─────────────────┤
│ memory_index    │    │ memory_index    │
│ memory_texts    │    │ memory_texts    │
└─────────────────┘    └─────────────────┘
agent私有存储
agent_shared = {
    "agent_id": "Agent1",
    
    # 记忆系统（私有）
    "memory_index": <FAISS索引对象>,  # 向量数据库
    "memory_texts": [],                # 对应的文本列表
    
    # 当前状态
    "visible_objects": [...],
    "retrieved_memories": [],          # 从FAISS检索到的记忆
    
    # 探索历史
    "explored_objects": set(),
    "action_history": []
}

5. 记忆系统工作流程
a. 在update memory node中，agent将新经验存入记忆
    def prep(self, shared):
        # Construct memory text
        memory_text = (
            f"At position {shared['position']}, "
            f"I saw {shared['visible_objects']}. "
            f"I decided to {shared['action']}. "
            f"Reason: {shared['action_reason']}"
        )
        
        return memory_text, shared["memory_index"], shared["memory_texts"]
    
    def exec(self, prep_res):
        memory_text, index, memory_texts = prep_res
        
        # Get embedding
        embedding = get_embedding(memory_text)
        
        # Add to memory
        add_to_memory(index, embedding, memory_text, memory_texts)
        
        return memory_text
文本→向量→FAISS

b. 在retrieve memory node检索相关记忆
    def prep(self, shared):
        visible_caption = shared.get("visible_caption") or ", ".join(map(str, shared.get("visible_objects", [])))
        position = shared["position"]
        
        # Construct query text using caption (works for both mock text and image-derived caption)
        query = f"What do I know about position {position} with what I see: {visible_caption}?"
        return query, shared["memory_index"], shared["memory_texts"]
    
    def exec(self, prep_res):
        query, index, memory_texts = prep_res
        
        # Get query vector
        query_emb = get_embedding(query)
        
        # Search memory
        results = search_memory(index, query_emb, memory_texts, top_k=3)
        
        return results
查询 → 向量 → 相似度搜索

6. 记忆共享通过消息
记忆是私有的，但是Agent可以通过消息队列分享关键信息。agent可以在决策时使用消息。

